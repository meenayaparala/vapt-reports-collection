
# 09. Brute Forcing Stay-Logged-In Cookie to Hijack Another User's Account

## 2. CVSS Score

**CVSS v3.1 Base Score: 7.5 (High)**
**CWE-256: Plaintext Storage of a Password**

---

## 3. OWASP Top 10 Reference

* **A07:2021 – Identification and Authentication Failures**
* **A02:2021 – Cryptographic Failures**

---

## 4. Description of Vulnerability

This lab demonstrates insecure handling of the stay-logged-in cookie that enables session hijacking by brute forcing the cookie value. The cookie value is a Base64-encoded string combining the username and an MD5 hash of the password. Due to weak hashing and predictable cookie construction, an attacker can brute force valid cookie values to impersonate other users.

---

## 5. Detailed Explanation of What We Performed

* Logged in with the "Stay logged in" option enabled.
* Examined the stay-logged-in cookie and decoded it from Base64, revealing the format: `username:md5(password)`.
* Verified the hash by hashing the known password using MD5.
* Sent the intercepted authenticated request with the stay-logged-in cookie to Burp Intruder.
* Added payloads with candidate passwords and configured payload processing rules to:

  * MD5 hash the password
  * Add a prefix of `username:`
  * Base64-encode the entire string
* Used a grep match rule to detect successful logins by the presence of the "Update email" button on the account page.
* Repeated the attack targeting the user `carlos` by adjusting the prefix and URL `id` parameter.
* Successfully brute forced Carlos’s stay-logged-in cookie, gaining unauthorized access.

---

## 6. Step-by-Step Procedure

### Step 1: Analyze Stay-Logged-In Cookie

1. Log in with "Stay logged in" option checked.
2. Inspect the stay-logged-in cookie.
3. Decode it from Base64 to see the format: `username:md5HashOfPassword`.
4. Confirm MD5 hash by hashing your password.

---

### Step 2: Set Up Burp Intruder Attack

5. Log out and capture a GET `/my-account?id=wiener` request.
6. Send the request to Burp Intruder.
7. Notice that the stay-logged-in cookie is automatically marked as a payload position.
8. Add your own password as a single payload.
9. Configure payload processing rules:

   * Hash: MD5
   * Add prefix: `wiener:`
   * Encode: Base64
10. Add a grep match rule for "Update email".
11. Start the attack to confirm the payload processing works.

---

### Step 3: Brute Force Carlos’s Cookie

12. Remove your password from payloads.
13. Add a list of candidate passwords.
14. Change the URL parameter `id=wiener` to `id=carlos`.
15. Change the Add prefix rule to `carlos:`.
16. Start the attack.
17. Identify the payload producing a response containing "Update email".
18. Use this payload as the valid stay-logged-in cookie for Carlos.

---

## 7. Impact of the Vulnerability

* Enables attackers to hijack other users’ accounts without knowing their passwords.
* Exploits weak hashing and predictable cookie construction.
* Undermines authentication by compromising session management.

---

## 8. Recommendations and Mitigations

* Do not store password hashes directly in cookies.
* Use secure, random session tokens instead of predictable values.
* Implement HttpOnly and Secure flags on cookies.
* Use stronger password hashing algorithms (e.g., bcrypt, Argon2).
* Enforce session expiration and invalidation on logout.

---

## 9. References

* [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
* [PortSwigger Lab: Session Management vulnerabilities](https://portswigger.net/web-security/authentication/session-management)

---

## 10. Proof of Concept

### Decoding Stay-Logged-In Cookie:

```bash
echo "d2llbmVyOjUxZGMzMGRkYzQ3M2Q0M2E2MDExZTllYmJhNmNhNzcw" | base64 -d
# Output: wiener:51dc30ddc473d43a6011e9ebba6ca770
```

### Payload Processing Rules:

* MD5 hash of candidate passwords
* Add prefix `carlos:` (or `wiener:` for self)
* Base64 encode the resulting string

